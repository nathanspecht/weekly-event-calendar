import React, { Component } from 'react'
import { Collection, ScrollSync } from 'react-virtualized'
import R, {
  identity,
  compose,
  values,
  length,
  keys,
  omit,
  set,
  lensProp,
  sortBy,
  prop,
  maxBy,
  equals,
} from 'ramda'
import Event from './Event'
import moment from 'moment'
import assignRows from './row-computer/assign-rows'
import { numHours, getPixelCount, getHourCount } from './util'

const sortedIds = compose(sortBy(identity), keys)

const objCount = compose(length, values)

class DaysEvents extends Component {
  constructor(props) {
    super(props)
    this.state = {
      extraCells: 0,
      isDragging: false,
      scrollLeft: undefined,
      numDays: 365,
    }
  }

  componentDidMount() {
    this.props.onUpdate(assignRows({ events: this.props.events })).then(() => {
      this.updateCollection()
    })
  }

  // increaseScroll = () => {
  //   this.setState({ scrollLeft: this.props.actualScrollLeft + 5 }, () => {
  //     this.scrollAnimation = requestAnimationFrame(this.increaseScroll)
  //   })
  // }
  //

  updateRows = props =>
    this.props.onUpdate(assignRows(props || this.props)).then(() => {
      this.updateCollection()
    })

  componentWillReceiveProps = nextProps => {
    if (objCount(nextProps.events) !== objCount(this.props.events)) {
      this.updateRows(nextProps)
    }
    if (typeof nextProps.scrollLeft === 'number') {
      // const numDays = Math.ceil((nextProps.scrollLeft + 2000) / 216)
      // this.setState({ numDays }, () => {
      //   this.updateCollection()
      this.setState({ scrollLeft: nextProps.scrollLeft })
      // })
    } else {
      this.setState({ scrollLeft: nextProps.scrollLeft })
    }
  }

  positionEvents = () => {
    const { events } = this.props
    const ids = sortedIds(events)

    return ids.map(id => {
      const event = events[id]
      const row = parseInt(event.row)
      const y = row * 75
      const x = getPixelCount(moment().startOf('day'), event.rangeStart)
      const width = getPixelCount(event.rangeStart, event.rangeEnd)
      const height = 70
      return { id, y, x, width, height }
    })
  }

  cellRenderer = ({ key, style, index }) => {
    const { numDays } = this.state
    if (index < numDays) {
      return this.weekDayCellRenderer({ key, style, index })
    }
    const adjustedIndex = index - numDays
    const events = this.props.events
    const ids = sortedIds(events)
    const id = ids[adjustedIndex]
    if (!id) {
      return <div id="phantom" key={key} style={style} />
    }
    const event = events[id]
    const translateY = style.top
    return (
      <div key={key}>
        <Event
          moveToTop={this.moveToTop}
          handleDrag={this.handleDrag}
          scrollTop={this.props.scrollTop}
          scrollLeft={this.props.actualScrollLeft}
          event={{ ...event, row: (style.top - 50) / 75 }}
          onClick={this.props.onEventClick}
          translateY={translateY}
          handleStop={this.handleStop}
          style={{ ...style, top: 0 }}
          handleStart={this.handleStart}
          isDragging={this.state.isDragging}
          describeEvent={this.props.describeEvent}
        />
      </div>
    )
  }

  cellSizeAndPositionGetter = events => {
    this.maxRow = R.reduce(R.max, 0, R.map(R.prop('row'), values(events)))
    const positionedEvents = this.positionEvents(events)
    return ({ index }) => {
      const numDays = this.state.numDays
      if (index < numDays) {
        return this.weekDayCellSizeAndPositionGetter({ index })
      }
      const adjustedIndex = index - numDays
      const datum = positionedEvents[adjustedIndex]
      if (!datum)
        return {
          height: 50,
          width: 50,
          x: 0,
          y: Math.max(550, (this.maxRow || 0) * 75 + 50),
        }

      return {
        height: datum.height,
        width: datum.width,
        x: datum.x,
        y: (datum.y || 0) + 50,
      }
    }
  }

  handleStop = extend => (_, drag, event) => {
    cancelAnimationFrame(this.scrollAnimation)
    const pixelOffset = drag.x
    const hourOffset = getHourCount(pixelOffset)
    const updatedEvent = {
      ...event,
      rangeStart:
        extend !== 'END'
          ? moment(event.rangeStart).add(hourOffset, 'hours')
          : event.rangeStart,
      rangeEnd:
        extend !== 'START'
          ? moment(event.rangeEnd).add(hourOffset, 'hours')
          : event.rangeEnd,
    }
    const nextEvents = assignRows({
      events: {
        ...this.props.events,
        [event.id]: updatedEvent,
      },
    })
    const update = this.props.onUpdate(nextEvents)
    if (update instanceof Promise) {
      // update with predicted events
      this.setState({ predictedEvents: nextEvents, isDragging: false })
      this.updateCollection()

      update.then(() => {
        // update with actual events
        this.setState({ predictedEvents: null })
        this.updateCollection()
      })
    } else {
      this.setState({ isDragging: false })
      this.updateCollection()
    }
  }

  handleStart = id => {
    const updatedEvents = assignRows({
      events: this.props.events,
      isolateId: id,
    })
    const eventsWithRows = this.props.onUpdate(updatedEvents).then(() => {
      this.setState({ isDragging: id }, () => this.updateCollection())
    })
  }

  updateCollection() {
    this.setState({ extraCells: this.state.extraCells >= 1 ? 0 : 1 })
  }

  updateNumDays = ({ scrollWidth, scrollLeft }) => {
    // if (scrollLeft + 1512 >= scrollWidth || scrollLeft + 1512 >= 216 * 6) {
    //   const numDays = Math.ceil((scrollWidth + 1512) / 216)
    //   this.setState({
    //     numDays: Math.min(365, numDays)
    //   })
    //   this.updateCollection()
    // }
  }

  weekDayCellRenderer = ({ key, style, index }) => {
    const day = moment()
      .startOf('day')
      .add(index, 'days')
    const dayFormatted = day.format('ddd M/DD')
    const color = {
      backgroundColor: moment().isSame(day, 'day')
        ? 'rgb(239,247,255)'
        : 'white',
    }
    return (
      <div
        style={{
          ...style,
          ...color,
          zIndex: -1,
        }}
        key={`${dayFormatted} ${index}`}
        className="br b--light-gray top-0 h-100"
      >
        <div className="bg-white w-100 tc pa2 bb b--light-gray" style={color}>
          {dayFormatted}
        </div>
      </div>
    )
  }

  weekDayCellSizeAndPositionGetter = ({ index }) => {
    const sizeAndPosition = {
      height: this.props.scrollHeight,
      width: 216,
      x: 216 * index,
      y: 0,
    }
    return sizeAndPosition
  }

  eventsCellCount = () =>
    values(this.props.events).length + this.state.extraCells + 2

  sortEvents = () => {
    const sortedEvents = assignRows({
      events: this.props.events,
      sortByProp: 'timestamp',
    })
    this.props.onUpdate(sortedEvents).then(() => this.updateCollection())
  }

  handleDrag = offsetX => {
    // const dir = R.clamp(-1, 1)(offsetX)
    // this.setState(
    //   {
    //     scrollLeft: this.props.actualScrollLeft + 20 * dir
    //   },
    //   () => this.setState({ scrollLeft: undefined })
    // )
  }

  moveToTop = id => {
    this.props
      .onUpdate(
        assignRows({
          events: this.props.events,
          moveToTopId: id,
        }),
      )
      .then(() => this.updateCollection())
  }

  render() {
    const { events } = this.props
    const cellCount = this.state.numDays + this.eventsCellCount()
    const cellSizeAndPositionGetter = this.cellSizeAndPositionGetter(events)

    return (
      <div>
        <Collection
          onScroll={args => {
            this.props.onScroll(args)
            /* this.updateNumDays(args) */
          }}
          ref={collection => (this.collection = collection)}
          cellCount={cellCount}
          cellRenderer={this.cellRenderer}
          cellSizeAndPositionGetter={cellSizeAndPositionGetter}
          verticalOverscanSize={this.maxRow * 75 + 50}
          scrollLeft={this.state.scrollLeft}
          height={600}
          width={1500}
          style={{ outline: 'none' }}
        />
      </div>
    )
  }
}

export default DaysEvents
