import R from 'ramda'
import moment from 'moment'

const isBetween = (date, event, inclusivity) =>
  moment(date).isBetween(event.rangeStart, event.rangeEnd, null, inclusivity)

const doesOverlap = event1 => event2 =>
  isBetween(event1.rangeStart, event2, '[]') ||
  isBetween(event1.rangeEnd, event2, '[]') ||
  isBetween(event2.rangeStart, event1, '[]') ||
  isBetween(event2.rangeEnd, event1, '[]')

const timestamp = R.compose(R.invoker(0, 'unix'), moment, R.prop('rangeStart'))

const sortBy = prop =>
  R.sortWith(
    prop === 'timestamp'
      ? [R.ascend(timestamp), R.ascend(R.prop('id'))]
      : [R.ascend(R.prop(prop))],
  )

const assignRow = (rows, { isolateId, isolateRow, moveToTopId }) => (
  acc,
  event,
) => {
  if (moveToTopId && moveToTopId === event.id) {
    return R.assoc(event.id, { ...event, row: 0 }, acc)
  }
  if (isolateId && isolateId === event.id) {
    return R.assoc(event.id, { ...event, row: isolateRow }, acc)
  }

  let i = 0
  let row = rows[i]

  while (R.any(doesOverlap(event))(row) || (isolateId && i === isolateRow)) {
    i++
    if (!rows[i]) rows[i] = []
    row = rows[i]
  }

  row.push(event)

  return R.assoc(event.id, { ...event, row: i }, acc)
}

const assignRows = ({ events, isolateId, sortByProp, moveToTopId }) => {
  const rows = moveToTopId ? [[events[moveToTopId]]] : [[]]

  const isolateRow = events && events[isolateId] && events[isolateId].row

  const eventsWithRows = R.reduce(
    assignRow(rows, { isolateId, isolateRow, moveToTopId }),
    {},
    sortBy('row')(R.values(events)),
  )

  return eventsWithRows
}

export default assignRows
